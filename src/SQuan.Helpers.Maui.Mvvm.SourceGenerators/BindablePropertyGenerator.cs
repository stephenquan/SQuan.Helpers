using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using SQuan.Helpers.Maui.Mvvm.SourceGenerators.Helpers;

namespace SQuan.Helpers.Maui.Mvvm.SourceGenerators;

/// <summary>
/// Generates bindable properties for classes marked with the appropriate attributes.
/// </summary>
/// <remarks>This source generator scans for properties in classes that are decorated with the 
/// <c>BindablePropertyAttribute</c> and generates corresponding <c>BindableProperty</c> fields. The generated code
/// includes logic for property change notifications and default value creation.</remarks>
[Generator]
public class BindablePropertyGenerator : IIncrementalGenerator
{
	/// <summary>
	/// Initializes the incremental generator by registering syntax and source output transformations.
	/// </summary>
	/// <remarks>This method sets up the generator to process syntax nodes representing properties with specific
	/// attributes. It registers a syntax provider to identify and transform relevant property declarations, and a source
	/// output action to generate code based on the transformed symbols.</remarks>
	/// <param name="context">The context used to configure the incremental generator. Provides access to syntax and semantic analysis tools.</param>
	public void Initialize(IncrementalGeneratorInitializationContext context)
	{
		var properties = context.SyntaxProvider
			.CreateSyntaxProvider(
				predicate: static (node, _)
					=> node is PropertyDeclarationSyntax propertyDeclaration
						&& propertyDeclaration.AttributeLists.Count > 0
						&& propertyDeclaration.Modifiers.Count > 0
						&& propertyDeclaration.Modifiers.IndexOf(SyntaxKind.PartialKeyword) != -1,
				transform: static (ctx, _) =>
				{
					var propertySyntax = (PropertyDeclarationSyntax)ctx.Node;
					var propertySymbol = ctx.SemanticModel.GetDeclaredSymbol(propertySyntax) as IPropertySymbol;
					if (propertySymbol is null)
					{
						return null;
					}

					bool hasAttribute = false;
					foreach (var attr in propertySymbol.GetAttributes())
					{
						if (attr.AttributeClass?.Name == "SQuan.Helpers.Maui.Mvvm.BindablePropertyAttribute" ||
							attr.AttributeClass?.ToDisplayString() == "SQuan.Helpers.Maui.Mvvm.BindablePropertyAttribute")
						{
							hasAttribute = true;
							break;
						}
					}

					return hasAttribute ? propertySymbol : null;
				})
			.Where(static symbol => symbol is not null);

		context.RegisterSourceOutput(properties, (spc, propertySymbol) =>
		{
			var propertyAttributes = propertySymbol!.GetAttributes();
			string defaultBindingMode = "OneWay";
			var classSymbol = propertySymbol!.ContainingType;
			var className = classSymbol.Name;
			var namespaceName = classSymbol.ContainingNamespace.ToDisplayString();
			var propertyName = propertySymbol.Name;
			var typeName = propertySymbol.Type.ToDisplayString();
			bool isValueType = propertySymbol.Type.IsValueType;
			var bareTypeName = isValueType ? typeName : typeName.Replace("?", "");
			PropertyDeclarationSyntax propertySyntax = (propertySymbol.DeclaringSyntaxReferences[0].GetSyntax() as PropertyDeclarationSyntax)!;

			var propertyModifiers = propertySyntax.Modifiers
				.Where(m => !m.IsKind(SyntaxKind.PartialKeyword))
				.Select(m => m.Text)
				.ToList();
			string access = propertyModifiers.Count > 0 ? string.Join(" ", propertyModifiers) : "public";

			string getModifiers = string.Empty;
			string setModifiers = string.Empty;
			if (propertySyntax.AccessorList is not null)
			{
				foreach (var accessor in propertySyntax.AccessorList.Accessors)
				{
					if (accessor.Kind() == SyntaxKind.GetAccessorDeclaration)
					{
						getModifiers = accessor.Modifiers.ToString();
					}
					else if (accessor.Kind() == SyntaxKind.SetAccessorDeclaration)
					{
						setModifiers = accessor.Modifiers.ToString();
					}
				}
			}

			string additionalChangingCommands = string.Empty;
			string additionalChangedCommands = string.Empty;

			foreach (var attr in propertyAttributes)
			{
				switch (attr.AttributeClass?.ToDisplayString())
				{
					case "SQuan.Helpers.Maui.Mvvm.BindablePropertyAttribute":
						defaultBindingMode = attr.GetNamedArgumentsAttributeValueByNameAsString("DefaultBindingMode", "OneWay");
						break;

					case "SQuan.Helpers.Maui.Mvvm.NotifyPropertyChangedForAttribute":
						foreach (var str in attr.ConstructorArguments.ToStringList())
						{
							additionalChangedCommands +=
$$"""
				(({{className}})b).OnPropertyChanged("{{str}}");
""";
						}
						break;
					case "SQuan.Helpers.Maui.Mvvm.NotifyPropertyChangingForAttribute":
						foreach (var str in attr.ConstructorArguments.ToStringList())
						{
							additionalChangedCommands +=
$$"""
				(({{className}})b).OnPropertyChanging("{{str}}");
""";
						}
						break;

					default:
						continue;
				}
			}

			var source = $@"
using System.ComponentModel;

// <auto-generated/>
#pragma warning disable
#nullable enable

namespace {namespaceName};

//[{{GeneratedCodeAttribute}}]
partial class {className}
{{
	/// <summary>
	/// Bindable property for <see cref=""{propertyName}""/>.
	/// </summary>
	{access} static readonly Microsoft.Maui.Controls.BindableProperty {propertyName}Property
		= Microsoft.Maui.Controls.BindableProperty.Create(nameof({propertyName}), typeof({bareTypeName}), typeof({className}),
			defaultBindingMode: Microsoft.Maui.Controls.BindingMode.{defaultBindingMode},
			propertyChanging: (b,o,n) =>
			{{
				(({className})b).On{propertyName}Changing(({typeName})n);
				(({className})b).On{propertyName}Changing(({typeName})o, ({typeName})n);
{additionalChangingCommands}
			}},
			propertyChanged: (b,o,n) =>
			{{
				(({className})b).On{propertyName}Changed(({typeName})n);
				(({className})b).On{propertyName}Changed(({typeName})o, ({typeName})n);
{additionalChangedCommands}
			}},
			defaultValueCreator: (b) => (({className})b).On{propertyName}CreateDefaultValue()
		);

	bool Is{propertyName}CreatingDefaultValue {{ get; set; }} = false;

	{access} partial {typeName} {propertyName}
	{{
		{getModifiers} get => Is{propertyName}CreatingDefaultValue ? field : ({typeName})GetValue({propertyName}Property);
		{setModifiers} set => SetValue({propertyName}Property, field = value);
	}}

	object On{propertyName}CreateDefaultValue()
	{{
		Is{propertyName}CreatingDefaultValue = true;
		object result = {propertyName};
		Is{propertyName}CreatingDefaultValue = false;
		return result;
	}}

	/// <summary>Executes the logic for when <see cref=""{propertyName}""/> is changing.</summary>
	/// <param name=""value"">The new property value being set.</param>
	/// <remarks>This method is invoked right before the value of <see cref=""{propertyName}""/> is changed.</remarks>
	partial void On{propertyName}Changing({typeName} value);

	/// <summary>Executes the logic for when <see cref=""{propertyName}""/> is changing.</summary>
	/// <param name=""oldValue"">The previous property value that is being replaced.</param>
	/// <param name=""newValue"">The new property value being set.</param>
	/// <remarks>This method is invoked right before the value of <see cref=""{propertyName}""/> is changed.</remarks>
	partial void On{propertyName}Changing({typeName} oldValue, {typeName} newValue);

	/// <summary>Executes the logic for when <see cref=""{propertyName}""/> just changed.</summary>
	/// <param name=""value"">The new property value that was set.</param>
	/// <remarks>This method is invoked right after the value of <see cref=""{propertyName}""/> is changed.</remarks>
	partial void On{propertyName}Changed({typeName} value);

	/// <summary>Executes the logic for when <see cref=""{propertyName}""/> just changed.</summary>
	/// <param name=""oldValue"">The previous property value that was replaced.</param>
	/// <param name=""newValue"">The new property value that was set.</param>
	/// <remarks>This method is invoked right after the value of <see cref=""{propertyName}""/> is changed.</remarks>
	partial void On{propertyName}Changed({typeName} oldValue, {typeName} newValue);
}}
";
			spc.AddSource($"{namespaceName}_{className}_{propertyName}_BindableProperty.g.cs", SourceText.From(source, Encoding.UTF8));
		});
	}
}
